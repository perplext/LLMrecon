// Package api provides a RESTful API for the access control system
package api

import (
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gorilla/mux"
	"github.com/perplext/LLMrecon/src/security/access"
)

// CreateVulnerabilityRequest represents a request to create a new vulnerability
type CreateVulnerabilityRequest struct {
	Title            string                 `json:"title"`
	Description      string                 `json:"description"`
	CVEID            string                 `json:"cve_id,omitempty"`
	Severity         string                 `json:"severity"`
	AffectedSystems  []string               `json:"affected_systems,omitempty"`
	RemediationSteps string                 `json:"remediation_steps,omitempty"`
	Tags             []string               `json:"tags,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// UpdateVulnerabilityRequest represents a request to update a vulnerability
type UpdateVulnerabilityRequest struct {
	Title            string                 `json:"title,omitempty"`
	Description      string                 `json:"description,omitempty"`
	CVEID            string                 `json:"cve_id,omitempty"`
	Severity         string                 `json:"severity,omitempty"`
	Status           string                 `json:"status,omitempty"`
	AssignedTo       string                 `json:"assigned_to,omitempty"`
	PatchNotes       string                 `json:"patch_notes,omitempty"`
	AffectedSystems  []string               `json:"affected_systems,omitempty"`
	RemediationSteps string                 `json:"remediation_steps,omitempty"`
	Tags             []string               `json:"tags,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// VulnerabilityResponse represents a vulnerability response
type VulnerabilityResponse struct {
	ID               string                 `json:"id"`
	Title            string                 `json:"title"`
	Description      string                 `json:"description"`
	CVEID            string                 `json:"cve_id,omitempty"`
	Severity         string                 `json:"severity"`
	Status           string                 `json:"status"`
	ReportedBy       string                 `json:"reported_by,omitempty"`
	AssignedTo       string                 `json:"assigned_to,omitempty"`
	CreatedAt        string                 `json:"created_at"`
	UpdatedAt        string                 `json:"updated_at"`
	PatchedAt        string                 `json:"patched_at,omitempty"`
	PatchNotes       string                 `json:"patch_notes,omitempty"`
	AffectedSystems  []string               `json:"affected_systems,omitempty"`
	RemediationSteps string                 `json:"remediation_steps,omitempty"`
	Tags             []string               `json:"tags,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// handleListVulnerabilities handles listing vulnerabilities with filtering
func (s *Server) handleListVulnerabilities(w http.ResponseWriter, r *http.Request) {
	// Get current user from context
	currentUser, ok := r.Context().Value("user").(*access.User)
	if !ok {
		WriteErrorResponse(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Check permission
	rbacManager := s.accessManager.GetRBACManager()
	if !rbacManager.HasPermission(r.Context(), currentUser, access.PermissionSecurityVulnerabilityView) {
		WriteErrorResponse(w, http.StatusForbidden, "Insufficient permissions")
		return
	}

	// Parse query parameters
	query := r.URL.Query()
	
	// Create filter
	filter := &access.VulnerabilityFilter{
		CVEID:      query.Get("cve_id"),
		Severity:   query.Get("severity"),
		Status:     query.Get("status"),
		ReportedBy: query.Get("reported_by"),
		AssignedTo: query.Get("assigned_to"),
	}
	
	// Parse time range
	if startDateStr := query.Get("start_date"); startDateStr != "" {
		startDate, err := time.Parse("2006-01-02", startDateStr)
		if err != nil {
			WriteErrorResponse(w, http.StatusBadRequest, "Invalid start_date format, expected YYYY-MM-DD")
			return
		}
		filter.StartDate = &startDate
	}
	
	if endDateStr := query.Get("end_date"); endDateStr != "" {
		endDate, err := time.Parse("2006-01-02", endDateStr)
		if err != nil {
			WriteErrorResponse(w, http.StatusBadRequest, "Invalid end_date format, expected YYYY-MM-DD")
			return
		}
		// Set to end of day
		endDate = endDate.Add(24*time.Hour - time.Second)
		filter.EndDate = &endDate
	}
	
	// Parse pagination parameters
	page, _ := strconv.Atoi(query.Get("page"))
	if page < 1 {
		page = 1
	}
	
	limit, _ := strconv.Atoi(query.Get("limit"))
	if limit < 1 || limit > 100 {
		limit = 20
	}
	
	filter.Offset = (page - 1) * limit
	filter.Limit = limit

	// Get vulnerabilities
	securityManager := s.accessManager.GetSecurityManager()
	vulnerabilities, err := securityManager.ListVulnerabilities(r.Context(), filter)
	if err != nil {
		WriteErrorResponse(w, http.StatusInternalServerError, "Failed to list vulnerabilities")
		return
	}

	// Get total count
	totalCount, err := securityManager.CountVulnerabilities(r.Context(), filter)
	if err != nil {
		WriteErrorResponse(w, http.StatusInternalServerError, "Failed to count vulnerabilities")
		return
	}

	// Convert vulnerabilities to response format
	var vulnResponses []VulnerabilityResponse
	for _, vuln := range vulnerabilities {
		vulnResponses = append(vulnResponses, convertVulnerabilityToResponse(vuln))
	}

	// Create response
	resp := struct {
		Vulnerabilities []VulnerabilityResponse `json:"vulnerabilities"`
		TotalCount      int64                   `json:"total_count"`
		Page            int                     `json:"page"`
		Limit           int                     `json:"limit"`
		TotalPages      int                     `json:"total_pages"`
	}{
		Vulnerabilities: vulnResponses,
		TotalCount:      totalCount,
		Page:            page,
		Limit:           limit,
		TotalPages:      int((totalCount + int64(limit) - 1) / int64(limit)),
	}

	// Return success response
	WriteSuccessResponse(w, http.StatusOK, "Vulnerabilities retrieved successfully", resp)
}

// handleCreateVulnerability handles creating a new vulnerability
func (s *Server) handleCreateVulnerability(w http.ResponseWriter, r *http.Request) {
	// Get current user from context
	currentUser, ok := r.Context().Value("user").(*access.User)
	if !ok {
		WriteErrorResponse(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Check permission
	rbacManager := s.accessManager.GetRBACManager()
	if !rbacManager.HasPermission(r.Context(), currentUser, access.PermissionSecurityVulnerabilityCreate) {
		WriteErrorResponse(w, http.StatusForbidden, "Insufficient permissions")
		return
	}

	// Parse request
	var req CreateVulnerabilityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		WriteErrorResponse(w, http.StatusBadRequest, "Invalid request format")
		return
	}

	// Validate input
	if req.Title == "" || req.Description == "" || req.Severity == "" {
		WriteErrorResponse(w, http.StatusBadRequest, "Title, description, and severity are required")
		return
	}

	// Validate severity
	validSeverities := []string{
		access.SeverityCritical,
		access.SeverityHigh,
		access.SeverityMedium,
		access.SeverityLow,
		access.SeverityInfo,
	}
	
	validSeverity := false
	for _, severity := range validSeverities {
		if req.Severity == severity {
			validSeverity = true
			break
		}
	}
	
	if !validSeverity {
		WriteErrorResponse(w, http.StatusBadRequest, "Invalid severity value")
		return
	}

	// Create vulnerability
	vulnerability := &access.Vulnerability{
		Title:            req.Title,
		Description:      req.Description,
		CVEID:            req.CVEID,
		Severity:         req.Severity,
		Status:           access.StatusOpen,
		ReportedBy:       currentUser.ID,
		AffectedSystems:  req.AffectedSystems,
		RemediationSteps: req.RemediationSteps,
		Tags:             req.Tags,
		Metadata:         req.Metadata,
	}

	securityManager := s.accessManager.GetSecurityManager()
	if err := securityManager.CreateVulnerability(r.Context(), vulnerability); err != nil {
		WriteErrorResponse(w, http.StatusInternalServerError, "Failed to create vulnerability")
		return
	}

	// Return success response
	WriteSuccessResponse(w, http.StatusCreated, "Vulnerability created successfully", convertVulnerabilityToResponse(vulnerability))
}

// handleGetVulnerability handles retrieving a vulnerability
func (s *Server) handleGetVulnerability(w http.ResponseWriter, r *http.Request) {
	// Get current user from context
	currentUser, ok := r.Context().Value("user").(*access.User)
	if !ok {
		WriteErrorResponse(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Check permission
	rbacManager := s.accessManager.GetRBACManager()
	if !rbacManager.HasPermission(r.Context(), currentUser, access.PermissionSecurityVulnerabilityView) {
		WriteErrorResponse(w, http.StatusForbidden, "Insufficient permissions")
		return
	}

	// Get vulnerability ID from URL
	vars := mux.Vars(r)
	vulnID := vars["id"]
	if vulnID == "" {
		WriteErrorResponse(w, http.StatusBadRequest, "Vulnerability ID is required")
		return
	}

	// Get vulnerability
	securityManager := s.accessManager.GetSecurityManager()
	vulnerability, err := securityManager.GetVulnerability(r.Context(), vulnID)
	if err != nil {
		WriteErrorResponse(w, http.StatusNotFound, "Vulnerability not found")
		return
	}

	// Return success response
	WriteSuccessResponse(w, http.StatusOK, "Vulnerability retrieved successfully", convertVulnerabilityToResponse(vulnerability))
}

// handleUpdateVulnerability handles updating a vulnerability
func (s *Server) handleUpdateVulnerability(w http.ResponseWriter, r *http.Request) {
	// Get current user from context
	currentUser, ok := r.Context().Value("user").(*access.User)
	if !ok {
		WriteErrorResponse(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Check permission
	rbacManager := s.accessManager.GetRBACManager()
	if !rbacManager.HasPermission(r.Context(), currentUser, access.PermissionSecurityVulnerabilityUpdate) {
		WriteErrorResponse(w, http.StatusForbidden, "Insufficient permissions")
		return
	}

	// Get vulnerability ID from URL
	vars := mux.Vars(r)
	vulnID := vars["id"]
	if vulnID == "" {
		WriteErrorResponse(w, http.StatusBadRequest, "Vulnerability ID is required")
		return
	}

	// Parse request
	var req UpdateVulnerabilityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		WriteErrorResponse(w, http.StatusBadRequest, "Invalid request format")
		return
	}

	// Get vulnerability
	securityManager := s.accessManager.GetSecurityManager()
	vulnerability, err := securityManager.GetVulnerability(r.Context(), vulnID)
	if err != nil {
		WriteErrorResponse(w, http.StatusNotFound, "Vulnerability not found")
		return
	}

	// Update vulnerability fields
	if req.Title != "" {
		vulnerability.Title = req.Title
	}
	
	if req.Description != "" {
		vulnerability.Description = req.Description
	}
	
	if req.CVEID != "" {
		vulnerability.CVEID = req.CVEID
	}
	
	if req.Severity != "" {
		// Validate severity
		validSeverities := []string{
			access.SeverityCritical,
			access.SeverityHigh,
			access.SeverityMedium,
			access.SeverityLow,
			access.SeverityInfo,
		}
		
		validSeverity := false
		for _, severity := range validSeverities {
			if req.Severity == severity {
				validSeverity = true
				break
			}
		}
		
		if !validSeverity {
			WriteErrorResponse(w, http.StatusBadRequest, "Invalid severity value")
			return
		}
		
		vulnerability.Severity = req.Severity
	}
	
	if req.Status != "" {
		// Validate status
		validStatuses := []string{
			access.StatusOpen,
			access.StatusInProgress,
			access.StatusPatched,
			access.StatusClosed,
		}
		
		validStatus := false
		for _, status := range validStatuses {
			if req.Status == status {
				validStatus = true
				break
			}
		}
		
		if !validStatus {
			WriteErrorResponse(w, http.StatusBadRequest, "Invalid status value")
			return
		}
		
		// If changing to patched or closed, set patched time
		if (req.Status == access.StatusPatched || req.Status == access.StatusClosed) && 
		   (vulnerability.Status != access.StatusPatched && vulnerability.Status != access.StatusClosed) {
			vulnerability.PatchedAt = time.Now()
		}
		
		vulnerability.Status = req.Status
	}
	
	if req.AssignedTo != "" {
		// Validate that the assigned user exists
		userManager := s.accessManager.GetUserManager()
		_, err := userManager.GetUserByID(r.Context(), req.AssignedTo)
		if err != nil {
			WriteErrorResponse(w, http.StatusBadRequest, "Assigned user does not exist")
			return
		}
		
		vulnerability.AssignedTo = req.AssignedTo
	}
	
	if req.PatchNotes != "" {
		vulnerability.PatchNotes = req.PatchNotes
	}
	
	if len(req.AffectedSystems) > 0 {
		vulnerability.AffectedSystems = req.AffectedSystems
	}
	
	if req.RemediationSteps != "" {
		vulnerability.RemediationSteps = req.RemediationSteps
	}
	
	if len(req.Tags) > 0 {
		vulnerability.Tags = req.Tags
	}
	
	if req.Metadata != nil {
		vulnerability.Metadata = req.Metadata
	}
	
	// Update timestamp
	vulnerability.UpdatedAt = time.Now()

	// Update vulnerability
	if err := securityManager.UpdateVulnerability(r.Context(), vulnerability); err != nil {
		WriteErrorResponse(w, http.StatusInternalServerError, "Failed to update vulnerability")
		return
	}

	// Return success response
	WriteSuccessResponse(w, http.StatusOK, "Vulnerability updated successfully", convertVulnerabilityToResponse(vulnerability))
}

// handleDeleteVulnerability handles deleting a vulnerability
func (s *Server) handleDeleteVulnerability(w http.ResponseWriter, r *http.Request) {
	// Get current user from context
	currentUser, ok := r.Context().Value("user").(*access.User)
	if !ok {
		WriteErrorResponse(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Check permission
	rbacManager := s.accessManager.GetRBACManager()
	if !rbacManager.HasPermission(r.Context(), currentUser, access.PermissionSecurityVulnerabilityDelete) {
		WriteErrorResponse(w, http.StatusForbidden, "Insufficient permissions")
		return
	}

	// Get vulnerability ID from URL
	vars := mux.Vars(r)
	vulnID := vars["id"]
	if vulnID == "" {
		WriteErrorResponse(w, http.StatusBadRequest, "Vulnerability ID is required")
		return
	}

	// Delete vulnerability
	securityManager := s.accessManager.GetSecurityManager()
	if err := securityManager.DeleteVulnerability(r.Context(), vulnID); err != nil {
		if strings.Contains(err.Error(), "not found") {
			WriteErrorResponse(w, http.StatusNotFound, "Vulnerability not found")
		} else {
			WriteErrorResponse(w, http.StatusInternalServerError, "Failed to delete vulnerability")
		}
		return
	}

	// Return success response
	WriteSuccessResponse(w, http.StatusOK, "Vulnerability deleted successfully", nil)
}

// convertVulnerabilityToResponse converts a vulnerability to a response format
func convertVulnerabilityToResponse(vulnerability *access.Vulnerability) VulnerabilityResponse {
	var patchedAt string
	if !vulnerability.PatchedAt.IsZero() {
		patchedAt = vulnerability.PatchedAt.Format(time.RFC3339)
	}

	return VulnerabilityResponse{
		ID:               vulnerability.ID,
		Title:            vulnerability.Title,
		Description:      vulnerability.Description,
		CVEID:            vulnerability.CVEID,
		Severity:         vulnerability.Severity,
		Status:           vulnerability.Status,
		ReportedBy:       vulnerability.ReportedBy,
		AssignedTo:       vulnerability.AssignedTo,
		CreatedAt:        vulnerability.CreatedAt.Format(time.RFC3339),
		UpdatedAt:        vulnerability.UpdatedAt.Format(time.RFC3339),
		PatchedAt:        patchedAt,
		PatchNotes:       vulnerability.PatchNotes,
		AffectedSystems:  vulnerability.AffectedSystems,
		RemediationSteps: vulnerability.RemediationSteps,
		Tags:             vulnerability.Tags,
		Metadata:         vulnerability.Metadata,
	}
}
