// Package db provides database implementations of the access control interfaces
package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/perplext/LLMrecon/src/security/access/interfaces"
	"github.com/perplext/LLMrecon/src/security/access/models"
)

// SQLVulnerabilityStore is a SQL implementation of VulnerabilityStore
type SQLVulnerabilityStore struct {
	db *sql.DB
}

// NewSQLVulnerabilityStore creates a new SQL-based vulnerability store
func NewSQLVulnerabilityStore(db *sql.DB) (interfaces.VulnerabilityStore, error) {
	store := &SQLVulnerabilityStore{
		db: db,
	}

	// Initialize database schema if needed
	if err := store.initSchema(); err != nil {
		return nil, fmt.Errorf("failed to initialize schema: %w", err)
	}

	return store, nil
}

// initSchema initializes the database schema
func (s *SQLVulnerabilityStore) initSchema() error {
	// Create vulnerabilities table
	_, err := s.db.Exec(`
		CREATE TABLE IF NOT EXISTS vulnerabilities (
			id TEXT PRIMARY KEY,
			title TEXT NOT NULL,
			description TEXT,
			cve TEXT,
			severity TEXT NOT NULL,
			status TEXT NOT NULL,
			affected_systems TEXT,
			reported_by TEXT,
			assigned_to TEXT,
			created_at TIMESTAMP NOT NULL,
			updated_at TIMESTAMP NOT NULL,
			resolved_at TIMESTAMP,
			metadata TEXT
		)
	`)
	if err != nil {
		return fmt.Errorf("failed to create vulnerabilities table: %w", err)
	}

	// Create indexes
	_, err = s.db.Exec(`CREATE INDEX IF NOT EXISTS idx_vulnerabilities_cve ON vulnerabilities(cve)`)
	if err != nil {
		return fmt.Errorf("failed to create cve index: %w", err)
	}

	_, err = s.db.Exec(`CREATE INDEX IF NOT EXISTS idx_vulnerabilities_severity ON vulnerabilities(severity)`)
	if err != nil {
		return fmt.Errorf("failed to create severity index: %w", err)
	}

	_, err = s.db.Exec(`CREATE INDEX IF NOT EXISTS idx_vulnerabilities_status ON vulnerabilities(status)`)
	if err != nil {
		return fmt.Errorf("failed to create status index: %w", err)
	}

	return nil
}

// CreateVulnerability creates a new vulnerability
func (s *SQLVulnerabilityStore) CreateVulnerability(ctx context.Context, vulnerability *interfaces.Vulnerability) error {
	// Serialize metadata and affected systems
	metadataJSON, err := json.Marshal(vulnerability.Metadata)
	if err != nil {
		return fmt.Errorf("failed to serialize metadata: %w", err)
	}

	affectedSystemsJSON, err := json.Marshal(vulnerability.AffectedSystems)
	if err != nil {
		return fmt.Errorf("failed to serialize affected systems: %w", err)
	}

	query := `
		INSERT INTO vulnerabilities (
			id, title, description, cve, severity, status, affected_systems,
			reported_by, assigned_to, created_at, updated_at, resolved_at, metadata
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`

	createdAt := time.Now().Format(time.RFC3339)
	if !vulnerability.ReportedAt.IsZero() {
		createdAt = vulnerability.ReportedAt.Format(time.RFC3339)
	}

	updatedAt := createdAt

	var resolvedAt interface{}
	if !vulnerability.ResolvedAt.IsZero() {
		resolvedAt = vulnerability.ResolvedAt.Format(time.RFC3339)
	} else {
		resolvedAt = nil
	}

	_, err = s.db.ExecContext(
		ctx,
		query,
		vulnerability.ID,
		vulnerability.Title,
		vulnerability.Description,
		vulnerability.CVE,
		string(vulnerability.Severity),
		string(vulnerability.Status),
		affectedSystemsJSON,
		vulnerability.ReportedBy,
		vulnerability.AssignedTo,
		createdAt,
		updatedAt,
		resolvedAt,
		metadataJSON,
	)
	if err != nil {
		return fmt.Errorf("failed to create vulnerability: %w", err)
	}

	return nil
}

// GetVulnerabilityByID retrieves a vulnerability by ID
func (s *SQLVulnerabilityStore) GetVulnerabilityByID(ctx context.Context, id string) (*interfaces.Vulnerability, error) {
	query := `
		SELECT id, title, description, cve, severity, status, affected_systems,
		       reported_by, assigned_to, created_at, updated_at, resolved_at, metadata
		FROM vulnerabilities
		WHERE id = ?
	`

	row := s.db.QueryRowContext(ctx, query, id)
	return s.scanVulnerability(row)
}

// GetVulnerabilityByCVE retrieves a vulnerability by CVE ID
func (s *SQLVulnerabilityStore) GetVulnerabilityByCVE(ctx context.Context, cve string) (*interfaces.Vulnerability, error) {
	query := `
		SELECT id, title, description, cve, severity, status, affected_systems,
		       reported_by, assigned_to, created_at, updated_at, resolved_at, metadata
		FROM vulnerabilities
		WHERE cve = ?
	`

	row := s.db.QueryRowContext(ctx, query, cve)
	return s.scanVulnerability(row)
}

// UpdateVulnerability updates an existing vulnerability
func (s *SQLVulnerabilityStore) UpdateVulnerability(ctx context.Context, vulnerability *interfaces.Vulnerability) error {
	// Check if vulnerability exists
	_, err := s.GetVulnerabilityByID(ctx, vulnerability.ID)
	if err != nil {
		return err
	}

	// Serialize metadata and affected systems
	metadataJSON, err := json.Marshal(vulnerability.Metadata)
	if err != nil {
		return fmt.Errorf("failed to serialize metadata: %w", err)
	}

	affectedSystemsJSON, err := json.Marshal(vulnerability.AffectedSystems)
	if err != nil {
		return fmt.Errorf("failed to serialize affected systems: %w", err)
	}

	query := `
		UPDATE vulnerabilities
		SET title = ?, description = ?, cve = ?, severity = ?, status = ?,
		    affected_systems = ?, reported_by = ?, assigned_to = ?, updated_at = ?,
		    resolved_at = ?, metadata = ?
		WHERE id = ?
	`

	updatedAt := time.Now().Format(time.RFC3339)

	var resolvedAt interface{}
	if !vulnerability.ResolvedAt.IsZero() {
		resolvedAt = vulnerability.ResolvedAt.Format(time.RFC3339)
	} else {
		resolvedAt = nil
	}

	_, err = s.db.ExecContext(
		ctx,
		query,
		vulnerability.Title,
		vulnerability.Description,
		vulnerability.CVE,
		string(vulnerability.Severity),
		string(vulnerability.Status),
		affectedSystemsJSON,
		vulnerability.ReportedBy,
		vulnerability.AssignedTo,
		updatedAt,
		resolvedAt,
		metadataJSON,
		vulnerability.ID,
	)
	if err != nil {
		return fmt.Errorf("failed to update vulnerability: %w", err)
	}

	return nil
}

// DeleteVulnerability deletes a vulnerability
func (s *SQLVulnerabilityStore) DeleteVulnerability(ctx context.Context, id string) error {
	query := `DELETE FROM vulnerabilities WHERE id = ?`
	result, err := s.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete vulnerability: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("vulnerability not found")
	}

	return nil
}

// ListVulnerabilities lists vulnerabilities with optional filtering
func (s *SQLVulnerabilityStore) ListVulnerabilities(ctx context.Context, filter map[string]interface{}, offset, limit int) ([]*interfaces.Vulnerability, int, error) {
	// Build query
	baseQuery := `
		SELECT id, title, description, cve, severity, status, affected_systems,
		       reported_by, assigned_to, created_at, updated_at, resolved_at, metadata
		FROM vulnerabilities
		WHERE 1=1
	`

	var conditions []string
	var args []interface{}

	// Add filter conditions
	if cve, ok := filter["cve"].(string); ok && cve != "" {
		conditions = append(conditions, "cve = ?")
		args = append(args, cve)
	}

	if severity, ok := filter["severity"].(string); ok && severity != "" {
		conditions = append(conditions, "severity = ?")
		args = append(args, severity)
	}

	if status, ok := filter["status"].(string); ok && status != "" {
		conditions = append(conditions, "status = ?")
		args = append(args, status)
	}

	if reportedBy, ok := filter["reported_by"].(string); ok && reportedBy != "" {
		conditions = append(conditions, "reported_by = ?")
		args = append(args, reportedBy)
	}

	if assignedTo, ok := filter["assigned_to"].(string); ok && assignedTo != "" {
		conditions = append(conditions, "assigned_to = ?")
		args = append(args, assignedTo)
	}

	if startDate, ok := filter["start_date"].(string); ok && startDate != "" {
		conditions = append(conditions, "created_at >= ?")
		args = append(args, startDate)
	}

	if endDate, ok := filter["end_date"].(string); ok && endDate != "" {
		conditions = append(conditions, "created_at <= ?")
		args = append(args, endDate)
	}

	// Build the final query
	query := baseQuery
	for _, condition := range conditions {
		query += " AND " + condition
	}

	// Add order by
	query += " ORDER BY created_at DESC"

	// Add limit and offset
	if limit > 0 {
		query += " LIMIT ?"
		args = append(args, limit)

		if offset > 0 {
			query += " OFFSET ?"
			args = append(args, offset)
		}
	}

	// Execute query
	rows, err := s.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to query vulnerabilities: %w", err)
	}
	defer rows.Close()

	// Collect results
	vulnerabilities := []*interfaces.Vulnerability{}
	for rows.Next() {
		vulnerability, err := s.scanVulnerabilityFromRows(rows)
		if err != nil {
			return nil, 0, err
		}
		vulnerabilities = append(vulnerabilities, vulnerability)
	}

	if err := rows.Err(); err != nil {
		return nil, 0, fmt.Errorf("error iterating vulnerabilities: %w", err)
	}

	// Count total vulnerabilities
	countQuery := `
		SELECT COUNT(*)
		FROM vulnerabilities
		WHERE 1=1
	`
	for _, condition := range conditions {
		countQuery += " AND " + condition
	}

	var count int
	err = s.db.QueryRowContext(ctx, countQuery, args[:len(args)-len(vulnerabilities)]...).Scan(&count)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count vulnerabilities: %w", err)
	}

	return vulnerabilities, count, nil
}

// scanVulnerability scans a vulnerability from a database row
func (s *SQLVulnerabilityStore) scanVulnerability(row *sql.Row) (*interfaces.Vulnerability, error) {
	var (
		id, title, description, cve, severityStr, statusStr, reportedBy, assignedTo string
		affectedSystemsJSON, metadataJSON []byte
		createdAtStr, updatedAtStr string
		resolvedAtStr sql.NullString
	)

	err := row.Scan(
		&id, &title, &description, &cve, &severityStr, &statusStr, &affectedSystemsJSON,
		&reportedBy, &assignedTo, &createdAtStr, &updatedAtStr, &resolvedAtStr, &metadataJSON,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("vulnerability not found")
		}
		return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
	}

	// Parse affected systems
	var affectedSystems []string
	if err := json.Unmarshal(affectedSystemsJSON, &affectedSystems); err != nil {
		return nil, fmt.Errorf("failed to parse affected systems: %w", err)
	}

	// Parse metadata
	var metadata map[string]interface{}
	if err := json.Unmarshal(metadataJSON, &metadata); err != nil {
		return nil, fmt.Errorf("failed to parse metadata: %w", err)
	}

	// Parse time fields
	createdAt, _ := time.Parse(time.RFC3339, createdAtStr)
	// We parse updatedAt but don't use it directly as it's not needed in our model

	// Create vulnerability
	vulnerability := &interfaces.Vulnerability{
		ID:              id,
		Title:           title,
		Description:     description,
		CVE:             cve,
		Severity:        models.VulnerabilitySeverity(severityStr),
		Status:          models.VulnerabilityStatus(statusStr),
		AffectedSystems: affectedSystems,
		ReportedBy:      reportedBy,
		AssignedTo:      assignedTo,
		ReportedAt:      createdAt,
		Metadata:        metadata,
	}

	// Set resolved at if not null
	if resolvedAtStr.Valid {
		resolvedAt, _ := time.Parse(time.RFC3339, resolvedAtStr.String)
		vulnerability.ResolvedAt = resolvedAt
	}

	return vulnerability, nil
}

// scanVulnerabilityFromRows scans a vulnerability from database rows
func (s *SQLVulnerabilityStore) scanVulnerabilityFromRows(rows *sql.Rows) (*interfaces.Vulnerability, error) {
	var (
		id, title, description, cve, severityStr, statusStr, reportedBy, assignedTo string
		affectedSystemsJSON, metadataJSON []byte
		createdAtStr, updatedAtStr string
		resolvedAtStr sql.NullString
	)

	err := rows.Scan(
		&id, &title, &description, &cve, &severityStr, &statusStr, &affectedSystemsJSON,
		&reportedBy, &assignedTo, &createdAtStr, &updatedAtStr, &resolvedAtStr, &metadataJSON,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
	}

	// Parse affected systems
	var affectedSystems []string
	if err := json.Unmarshal(affectedSystemsJSON, &affectedSystems); err != nil {
		return nil, fmt.Errorf("failed to parse affected systems: %w", err)
	}

	// Parse metadata
	var metadata map[string]interface{}
	if err := json.Unmarshal(metadataJSON, &metadata); err != nil {
		return nil, fmt.Errorf("failed to parse metadata: %w", err)
	}

	// Parse time fields
	createdAt, _ := time.Parse(time.RFC3339, createdAtStr)
	// We parse updatedAt but don't use it directly as it's not needed in our model

	// Create vulnerability
	vulnerability := &interfaces.Vulnerability{
		ID:              id,
		Title:           title,
		Description:     description,
		CVE:             cve,
		Severity:        models.VulnerabilitySeverity(severityStr),
		Status:          models.VulnerabilityStatus(statusStr),
		AffectedSystems: affectedSystems,
		ReportedBy:      reportedBy,
		AssignedTo:      assignedTo,
		ReportedAt:      createdAt,
		Metadata:        metadata,
	}

	// Set resolved at if not null
	if resolvedAtStr.Valid {
		resolvedAt, _ := time.Parse(time.RFC3339, resolvedAtStr.String)
		vulnerability.ResolvedAt = resolvedAt
	}

	return vulnerability, nil
}

// Close closes the SQL connection
func (s *SQLVulnerabilityStore) Close() error {
	return s.db.Close()
}
