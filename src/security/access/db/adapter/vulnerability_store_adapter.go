// Package adapter provides adapters between database interfaces and domain models
package adapter

import (
	"context"

	"github.com/perplext/LLMrecon/src/security/access/interfaces"
	"github.com/perplext/LLMrecon/src/security/access/models"
)

// DBVulnerability represents a security vulnerability in the database
type DBVulnerability struct {
	ID              string
	Title           string
	Description     string
	CVE             string
	Severity        string
	Status          string
	AffectedSystems []string
	ReportedBy      string
	AssignedTo      string
	ReportedAt      string
	MitigatedAt     string
	MitigatedBy     string
	ResolvedAt      string
	ResolvedBy      string
	Metadata        map[string]interface{}
}

// DBVulnerabilityStore defines the interface for vulnerability storage operations in the database
type DBVulnerabilityStore interface {
	// CreateVulnerability creates a new vulnerability
	CreateVulnerability(ctx context.Context, vulnerability *interfaces.Vulnerability) error
	
	// GetVulnerabilityByID retrieves a vulnerability by ID
	GetVulnerabilityByID(ctx context.Context, id string) (*interfaces.Vulnerability, error)
	
	// GetVulnerabilityByCVE retrieves a vulnerability by CVE ID
	GetVulnerabilityByCVE(ctx context.Context, cve string) (*interfaces.Vulnerability, error)
	
	// UpdateVulnerability updates an existing vulnerability
	UpdateVulnerability(ctx context.Context, vulnerability *interfaces.Vulnerability) error
	
	// DeleteVulnerability deletes a vulnerability
	DeleteVulnerability(ctx context.Context, id string) error
	
	// ListVulnerabilities lists vulnerabilities with optional filtering
	ListVulnerabilities(ctx context.Context, filter map[string]interface{}, offset, limit int) ([]*interfaces.Vulnerability, int, error)
	
	// Close closes the vulnerability store
	Close() error
}

// VulnerabilityStoreAdapter adapts between the database and interfaces.VulnerabilityStore
type VulnerabilityStoreAdapter struct {
	store interfaces.VulnerabilityStore
}

// NewVulnerabilityStoreAdapter creates a new vulnerability store adapter
func NewVulnerabilityStoreAdapter(store interfaces.VulnerabilityStore) interfaces.VulnerabilityStore {
	return store
}

// convertInterfaceVulnerabilityToDBVulnerability converts an interfaces.Vulnerability to a DBVulnerability
func convertInterfaceVulnerabilityToDBVulnerability(vulnerability *interfaces.Vulnerability) *DBVulnerability {
	if vulnerability == nil {
		return nil
	}

	dbVuln := &DBVulnerability{
		ID:              vulnerability.ID,
		Title:           vulnerability.Title,
		Description:     vulnerability.Description,
		CVE:             vulnerability.CVE,
		Severity:        string(vulnerability.Severity),
		Status:          string(vulnerability.Status),
		AffectedSystems: vulnerability.AffectedSystems,
		ReportedBy:      vulnerability.ReportedBy,
		AssignedTo:      vulnerability.AssignedTo,
		Metadata:        vulnerability.Metadata,
	}

	if !vulnerability.ReportedAt.IsZero() {
		dbVuln.ReportedAt = vulnerability.ReportedAt.Format(time.RFC3339)
	}
	if !vulnerability.MitigatedAt.IsZero() {
		dbVuln.MitigatedAt = vulnerability.MitigatedAt.Format(time.RFC3339)
		dbVuln.MitigatedBy = vulnerability.MitigatedBy
	}
	if !vulnerability.ResolvedAt.IsZero() {
		dbVuln.ResolvedAt = vulnerability.ResolvedAt.Format(time.RFC3339)
		dbVuln.ResolvedBy = vulnerability.ResolvedBy
	}

	return dbVuln
}

// convertDBVulnerabilityToInterfaceVulnerability converts a DBVulnerability to an interfaces.Vulnerability
func convertDBVulnerabilityToInterfaceVulnerability(vulnerability *DBVulnerability) *interfaces.Vulnerability {
	if vulnerability == nil {
		return nil
	}

	ifaceVuln := &interfaces.Vulnerability{
		ID:              vulnerability.ID,
		Title:           vulnerability.Title,
		Description:     vulnerability.Description,
		CVE:             vulnerability.CVE,
		Severity:        models.VulnerabilitySeverity(vulnerability.Severity),
		Status:          models.VulnerabilityStatus(vulnerability.Status),
		AffectedSystems: vulnerability.AffectedSystems,
		ReportedBy:      vulnerability.ReportedBy,
		AssignedTo:      vulnerability.AssignedTo,
		Metadata:        vulnerability.Metadata,
	}

	// Parse time fields
	if vulnerability.ReportedAt != "" {
		reportedAt, _ := time.Parse(time.RFC3339, vulnerability.ReportedAt)
		ifaceVuln.ReportedAt = reportedAt
	}
	if vulnerability.MitigatedAt != "" {
		mitigatedAt, _ := time.Parse(time.RFC3339, vulnerability.MitigatedAt)
		ifaceVuln.MitigatedAt = mitigatedAt
		ifaceVuln.MitigatedBy = vulnerability.MitigatedBy
	}
	if vulnerability.ResolvedAt != "" {
		resolvedAt, _ := time.Parse(time.RFC3339, vulnerability.ResolvedAt)
		ifaceVuln.ResolvedAt = resolvedAt
		ifaceVuln.ResolvedBy = vulnerability.ResolvedBy
	}

	return ifaceVuln
}

// convertDBVulnerabilitiesToInterfaceVulnerabilities converts a slice of DBVulnerability to a slice of interfaces.Vulnerability
func convertDBVulnerabilitiesToInterfaceVulnerabilities(vulnerabilities []*DBVulnerability) []*interfaces.Vulnerability {
	if vulnerabilities == nil {
		return nil
	}
	result := make([]*interfaces.Vulnerability, len(vulnerabilities))
	for i, vulnerability := range vulnerabilities {
		result[i] = convertDBVulnerabilityToInterfaceVulnerability(vulnerability)
	}
	return result
}

// CreateVulnerability creates a new vulnerability
func (a *VulnerabilityStoreAdapter) CreateVulnerability(ctx context.Context, vulnerability *interfaces.Vulnerability) error {
	return a.store.CreateVulnerability(ctx, vulnerability)
}

// GetVulnerabilityByID retrieves a vulnerability by ID
func (a *VulnerabilityStoreAdapter) GetVulnerabilityByID(ctx context.Context, id string) (*interfaces.Vulnerability, error) {
	return a.store.GetVulnerabilityByID(ctx, id)
}

// GetVulnerabilityByCVE retrieves a vulnerability by CVE ID
func (a *VulnerabilityStoreAdapter) GetVulnerabilityByCVE(ctx context.Context, cve string) (*interfaces.Vulnerability, error) {
	return a.store.GetVulnerabilityByCVE(ctx, cve)
}

// UpdateVulnerability updates an existing vulnerability
func (a *VulnerabilityStoreAdapter) UpdateVulnerability(ctx context.Context, vulnerability *interfaces.Vulnerability) error {
	return a.store.UpdateVulnerability(ctx, vulnerability)
}

// DeleteVulnerability deletes a vulnerability
func (a *VulnerabilityStoreAdapter) DeleteVulnerability(ctx context.Context, id string) error {
	return a.store.DeleteVulnerability(ctx, id)
}

// ListVulnerabilities lists vulnerabilities with optional filtering
func (a *VulnerabilityStoreAdapter) ListVulnerabilities(ctx context.Context, filter map[string]interface{}, offset, limit int) ([]*interfaces.Vulnerability, int, error) {
	return a.store.ListVulnerabilities(ctx, filter, offset, limit)
}

// Close closes the vulnerability store
func (a *VulnerabilityStoreAdapter) Close() error {
	return a.store.Close()
}
