// Package detection provides the vulnerability detection engine for LLM responses
package detection

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"time"
)

// StringMatcher is a detector that matches strings in LLM responses
type StringMatcher struct{}

// NewStringMatcher creates a new string matcher
func NewStringMatcher() *StringMatcher {
	return &StringMatcher{}
}

// Name returns the name of the detector
func (d *StringMatcher) Name() string {
	return "string_matcher"
}

// Detect detects vulnerabilities in an LLM response
func (d *StringMatcher) Detect(ctx context.Context, response string, criteria DetectionCriteria) (*DetectionResult, error) {
	if criteria.Type != StringMatch {
		return nil, fmt.Errorf("invalid criteria type for string matcher: %s", criteria.Type)
	}

	if criteria.Match == "" {
		return nil, fmt.Errorf("match string is required for string matcher")
	}

	// Normalize response and match string based on case sensitivity
	normalizedResponse := response
	normalizedMatch := criteria.Match
	if !criteria.CaseSensitive {
		normalizedResponse = strings.ToLower(response)
		normalizedMatch = strings.ToLower(criteria.Match)
	}

	// Check condition
	var detected bool
	var matchedContent []string
	switch criteria.Condition {
	case "contains":
		if strings.Contains(normalizedResponse, normalizedMatch) {
			detected = true
			matchedContent = []string{criteria.Match}
		}
	case "not_contains":
		if !strings.Contains(normalizedResponse, normalizedMatch) {
			detected = true
		}
	case "starts_with":
		if strings.HasPrefix(normalizedResponse, normalizedMatch) {
			detected = true
			matchedContent = []string{criteria.Match}
		}
	case "ends_with":
		if strings.HasSuffix(normalizedResponse, normalizedMatch) {
			detected = true
			matchedContent = []string{criteria.Match}
		}
	default:
		// Default to contains if condition is not specified
		if strings.Contains(normalizedResponse, normalizedMatch) {
			detected = true
			matchedContent = []string{criteria.Match}
		}
	}

	// Get vulnerability type and severity from context
	vulnType := PromptInjection // Default
	severity := Medium          // Default
	if criteria.Context != nil {
		if vt, ok := criteria.Context["vulnerability_type"].(string); ok {
			vulnType = VulnerabilityType(vt)
		}
		if s, ok := criteria.Context["severity"].(string); ok {
			severity = SeverityLevel(s)
		}
	}

	// Calculate confidence score (100 if detected, 0 if not)
	confidenceScore := 0
	if detected {
		confidenceScore = 100
	}

	// Create result
	result := &DetectionResult{
		Detected:          detected,
		VulnerabilityType: vulnType,
		Severity:          severity,
		ConfidenceScore:   confidenceScore,
		DetectionMethod:   StringMatch,
		MatchedContent:    matchedContent,
		Context: map[string]interface{}{
			"match_string": criteria.Match,
			"condition":    criteria.Condition,
		},
		Timestamp: time.Now(),
	}

	return result, nil
}

// RegexMatcher is a detector that matches regex patterns in LLM responses
type RegexMatcher struct{}

// NewRegexMatcher creates a new regex matcher
func NewRegexMatcher() *RegexMatcher {
	return &RegexMatcher{}
}

// Name returns the name of the detector
func (d *RegexMatcher) Name() string {
	return "regex_matcher"
}

// Detect detects vulnerabilities in an LLM response
func (d *RegexMatcher) Detect(ctx context.Context, response string, criteria DetectionCriteria) (*DetectionResult, error) {
	if criteria.Type != RegexMatch {
		return nil, fmt.Errorf("invalid criteria type for regex matcher: %s", criteria.Type)
	}

	if criteria.Pattern == "" {
		return nil, fmt.Errorf("pattern is required for regex matcher")
	}

	// Compile regex
	var regexOptions string
	if !criteria.CaseSensitive {
		regexOptions = "(?i)"
	}
	regex, err := regexp.Compile(regexOptions + criteria.Pattern)
	if err != nil {
		return nil, fmt.Errorf("invalid regex pattern: %w", err)
	}

	// Find matches
	matches := regex.FindAllString(response, -1)

	// Check condition
	var detected bool
	switch criteria.Condition {
	case "contains":
		detected = len(matches) > 0
	case "not_contains":
		detected = len(matches) == 0
	default:
		// Default to contains if condition is not specified
		detected = len(matches) > 0
	}

	// Get vulnerability type and severity from context
	vulnType := PromptInjection // Default
	severity := Medium          // Default
	if criteria.Context != nil {
		if vt, ok := criteria.Context["vulnerability_type"].(string); ok {
			vulnType = VulnerabilityType(vt)
		}
		if s, ok := criteria.Context["severity"].(string); ok {
			severity = SeverityLevel(s)
		}
	}

	// Calculate confidence score (100 if detected, 0 if not)
	confidenceScore := 0
	if detected {
		confidenceScore = 100
	}

	// Create result
	result := &DetectionResult{
		Detected:          detected,
		VulnerabilityType: vulnType,
		Severity:          severity,
		ConfidenceScore:   confidenceScore,
		DetectionMethod:   RegexMatch,
		MatchedContent:    matches,
		Context: map[string]interface{}{
			"pattern":     criteria.Pattern,
			"condition":   criteria.Condition,
			"match_count": len(matches),
		},
		Timestamp: time.Now(),
	}

	return result, nil
}

// SemanticMatcher is a detector that performs semantic matching on LLM responses
type SemanticMatcher struct {
	// embedder is the service for generating embeddings
	embedder EmbeddingService
}

// EmbeddingService is the interface for generating embeddings
type EmbeddingService interface {
	// GetEmbedding gets an embedding for a text
	GetEmbedding(ctx context.Context, text string) ([]float64, error)
	// GetSimilarity gets the similarity between two texts
	GetSimilarity(ctx context.Context, text1, text2 string) (float64, error)
}

// NewSemanticMatcher creates a new semantic matcher
func NewSemanticMatcher(embedder EmbeddingService) *SemanticMatcher {
	return &SemanticMatcher{
		embedder: embedder,
	}
}

// Name returns the name of the detector
func (d *SemanticMatcher) Name() string {
	return "semantic_matcher"
}

// Detect detects vulnerabilities in an LLM response
func (d *SemanticMatcher) Detect(ctx context.Context, response string, criteria DetectionCriteria) (*DetectionResult, error) {
	if criteria.Type != SemanticMatch {
		return nil, fmt.Errorf("invalid criteria type for semantic matcher: %s", criteria.Type)
	}

	if criteria.Criteria == "" {
		return nil, fmt.Errorf("criteria is required for semantic matcher")
	}

	if d.embedder == nil {
		// Fallback to keyword-based approach if embedder is not available
		return d.fallbackDetect(ctx, response, criteria)
	}

	// Get similarity between response and criteria
	similarity, err := d.embedder.GetSimilarity(ctx, response, criteria.Criteria)
	if err != nil {
		return nil, fmt.Errorf("failed to get similarity: %w", err)
	}

	// Convert similarity to percentage
	similarityPercentage := similarity * 100

	// Get threshold
	threshold := 70.0 // Default
	if criteria.Threshold > 0 {
		threshold = float64(criteria.Threshold)
	}

	// Check condition
	var detected bool
	switch criteria.Condition {
	case "above_threshold":
		detected = similarityPercentage >= threshold
	case "below_threshold":
		detected = similarityPercentage < threshold
	default:
		// Default to above_threshold if condition is not specified
		detected = similarityPercentage >= threshold
	}

	// Get vulnerability type and severity from context
	vulnType := PromptInjection // Default
	severity := Medium          // Default
	if criteria.Context != nil {
		if vt, ok := criteria.Context["vulnerability_type"].(string); ok {
			vulnType = VulnerabilityType(vt)
		}
		if s, ok := criteria.Context["severity"].(string); ok {
			severity = SeverityLevel(s)
		}
	}

	// Calculate confidence score based on similarity percentage
	confidenceScore := int(similarityPercentage)

	// Create result
	result := &DetectionResult{
		Detected:          detected,
		VulnerabilityType: vulnType,
		Severity:          severity,
		ConfidenceScore:   confidenceScore,
		DetectionMethod:   SemanticMatch,
		Context: map[string]interface{}{
			"criteria":             criteria.Criteria,
			"threshold":            threshold,
			"similarity":           similarity,
			"similarity_percentage": similarityPercentage,
			"condition":            criteria.Condition,
		},
		Timestamp: time.Now(),
	}

	return result, nil
}

// fallbackDetect is a fallback implementation for semantic matching
func (d *SemanticMatcher) fallbackDetect(ctx context.Context, response string, criteria DetectionCriteria) (*DetectionResult, error) {
	// Split criteria into keywords
	keywords := strings.Split(criteria.Criteria, ",")
	matchCount := 0
	
	for _, keyword := range keywords {
		keyword = strings.TrimSpace(keyword)
		if strings.Contains(strings.ToLower(response), strings.ToLower(keyword)) {
			matchCount++
		}
	}
	
	// Calculate match percentage
	matchPercentage := 0.0
	if len(keywords) > 0 {
		matchPercentage = float64(matchCount) / float64(len(keywords)) * 100
	}
	
	// Get threshold
	threshold := 70.0 // Default
	if criteria.Threshold > 0 {
		threshold = float64(criteria.Threshold)
	}
	
	// Determine if detected based on match percentage
	var detected bool
	switch criteria.Condition {
	case "above_threshold":
		detected = matchPercentage >= threshold
	case "below_threshold":
		detected = matchPercentage < threshold
	default:
		// Default to above_threshold if condition is not specified
		detected = matchPercentage >= threshold
	}
	
	// Get vulnerability type and severity from context
	vulnType := PromptInjection // Default
	severity := Medium          // Default
	if criteria.Context != nil {
		if vt, ok := criteria.Context["vulnerability_type"].(string); ok {
			vulnType = VulnerabilityType(vt)
		}
		if s, ok := criteria.Context["severity"].(string); ok {
			severity = SeverityLevel(s)
		}
	}
	
	// Calculate confidence score based on match percentage
	confidenceScore := int(matchPercentage)
	
	// Create result
	result := &DetectionResult{
		Detected:          detected,
		VulnerabilityType: vulnType,
		Severity:          severity,
		ConfidenceScore:   confidenceScore,
		DetectionMethod:   SemanticMatch,
		Context: map[string]interface{}{
			"criteria":        criteria.Criteria,
			"threshold":       threshold,
			"match_percentage": matchPercentage,
			"match_count":     matchCount,
			"keyword_count":   len(keywords),
			"condition":       criteria.Condition,
			"fallback":        true,
		},
		Timestamp: time.Now(),
	}
	
	return result, nil
}

// HybridMatcher is a detector that combines multiple detection methods
type HybridMatcher struct {
	// stringMatcher is the string matcher
	stringMatcher *StringMatcher
	// regexMatcher is the regex matcher
	regexMatcher *RegexMatcher
	// semanticMatcher is the semantic matcher
	semanticMatcher *SemanticMatcher
}

// NewHybridMatcher creates a new hybrid matcher
func NewHybridMatcher(semanticMatcher *SemanticMatcher) *HybridMatcher {
	return &HybridMatcher{
		stringMatcher:   NewStringMatcher(),
		regexMatcher:    NewRegexMatcher(),
		semanticMatcher: semanticMatcher,
	}
}

// Name returns the name of the detector
func (d *HybridMatcher) Name() string {
	return "hybrid_matcher"
}

// Detect detects vulnerabilities in an LLM response
func (d *HybridMatcher) Detect(ctx context.Context, response string, criteria DetectionCriteria) (*DetectionResult, error) {
	if criteria.Type != HybridMatch {
		return nil, fmt.Errorf("invalid criteria type for hybrid matcher: %s", criteria.Type)
	}

	// Get sub-criteria from context
	subCriteria, ok := criteria.Context["sub_criteria"].([]DetectionCriteria)
	if !ok || len(subCriteria) == 0 {
		return nil, fmt.Errorf("sub_criteria is required for hybrid matcher")
	}

	// Get aggregation strategy from context
	strategy, _ := criteria.Context["aggregation_strategy"].(string)
	if strategy == "" {
		strategy = "any" // Default
	}

	// Detect using sub-criteria
	var results []*DetectionResult
	for _, sc := range subCriteria {
		var result *DetectionResult
		var err error

		switch sc.Type {
		case StringMatch:
			result, err = d.stringMatcher.Detect(ctx, response, sc)
		case RegexMatch:
			result, err = d.regexMatcher.Detect(ctx, response, sc)
		case SemanticMatch:
			result, err = d.semanticMatcher.Detect(ctx, response, sc)
		default:
			return nil, fmt.Errorf("unsupported detection type in sub-criteria: %s", sc.Type)
		}

		if err != nil {
			return nil, fmt.Errorf("sub-criteria detection failed: %w", err)
		}

		results = append(results, result)
	}

	// Aggregate results
	var detected bool
	var confidenceScore int
	var matchedContent []string
	var detailsMap map[string]interface{}

	switch strategy {
	case "any":
		detected, confidenceScore, matchedContent, detailsMap = d.aggregateAny(results)
	case "all":
		detected, confidenceScore, matchedContent, detailsMap = d.aggregateAll(results)
	case "majority":
		detected, confidenceScore, matchedContent, detailsMap = d.aggregateMajority(results)
	case "weighted":
		detected, confidenceScore, matchedContent, detailsMap = d.aggregateWeighted(results, criteria.Context)
	default:
		return nil, fmt.Errorf("unsupported aggregation strategy: %s", strategy)
	}

	// Get vulnerability type and severity from context
	vulnType := PromptInjection // Default
	severity := Medium          // Default
	if criteria.Context != nil {
		if vt, ok := criteria.Context["vulnerability_type"].(string); ok {
			vulnType = VulnerabilityType(vt)
		}
		if s, ok := criteria.Context["severity"].(string); ok {
			severity = SeverityLevel(s)
		}
	}

	// Create result
	result := &DetectionResult{
		Detected:          detected,
		VulnerabilityType: vulnType,
		Severity:          severity,
		ConfidenceScore:   confidenceScore,
		DetectionMethod:   HybridMatch,
		MatchedContent:    matchedContent,
		Context:           detailsMap,
		Timestamp:         time.Now(),
	}

	return result, nil
}

// aggregateAny aggregates results using the "any" strategy
func (d *HybridMatcher) aggregateAny(results []*DetectionResult) (bool, int, []string, map[string]interface{}) {
	detected := false
	maxScore := 0
	var matchedContent []string
	detailsMap := map[string]interface{}{
		"aggregation_strategy": "any",
		"sub_results":          results,
	}

	for _, result := range results {
		if result.Detected {
			detected = true
			if result.ConfidenceScore > maxScore {
				maxScore = result.ConfidenceScore
			}
			matchedContent = append(matchedContent, result.MatchedContent...)
		}
	}

	return detected, maxScore, matchedContent, detailsMap
}

// aggregateAll aggregates results using the "all" strategy
func (d *HybridMatcher) aggregateAll(results []*DetectionResult) (bool, int, []string, map[string]interface{}) {
	detected := true
	totalScore := 0
	var matchedContent []string
	detailsMap := map[string]interface{}{
		"aggregation_strategy": "all",
		"sub_results":          results,
	}

	for _, result := range results {
		if !result.Detected {
			detected = false
		}
		totalScore += result.ConfidenceScore
		matchedContent = append(matchedContent, result.MatchedContent...)
	}

	// Calculate average score
	avgScore := 0
	if len(results) > 0 {
		avgScore = totalScore / len(results)
	}

	return detected, avgScore, matchedContent, detailsMap
}

// aggregateMajority aggregates results using the "majority" strategy
func (d *HybridMatcher) aggregateMajority(results []*DetectionResult) (bool, int, []string, map[string]interface{}) {
	detectedCount := 0
	totalScore := 0
	var matchedContent []string
	detailsMap := map[string]interface{}{
		"aggregation_strategy": "majority",
		"sub_results":          results,
	}

	for _, result := range results {
		if result.Detected {
			detectedCount++
		}
		totalScore += result.ConfidenceScore
		matchedContent = append(matchedContent, result.MatchedContent...)
	}

	// Calculate majority
	detected := false
	if len(results) > 0 && detectedCount > len(results)/2 {
		detected = true
	}

	// Calculate average score
	avgScore := 0
	if len(results) > 0 {
		avgScore = totalScore / len(results)
	}

	return detected, avgScore, matchedContent, detailsMap
}

// aggregateWeighted aggregates results using the "weighted" strategy
func (d *HybridMatcher) aggregateWeighted(results []*DetectionResult, context map[string]interface{}) (bool, int, []string, map[string]interface{}) {
	weights, _ := context["weights"].(map[string]float64)
	if weights == nil {
		// Default weights
		weights = map[string]float64{
			string(StringMatch):   1.0,
			string(RegexMatch):    1.0,
			string(SemanticMatch): 1.0,
		}
	}

	weightedScore := 0.0
	totalWeight := 0.0
	var matchedContent []string
	detailsMap := map[string]interface{}{
		"aggregation_strategy": "weighted",
		"weights":              weights,
		"sub_results":          results,
	}

	for _, result := range results {
		weight, ok := weights[string(result.DetectionMethod)]
		if !ok {
			weight = 1.0 // Default weight
		}
		weightedScore += float64(result.ConfidenceScore) * weight
		totalWeight += weight
		matchedContent = append(matchedContent, result.MatchedContent...)
	}

	// Calculate weighted average score
	finalScore := 0
	if totalWeight > 0 {
		finalScore = int(weightedScore / totalWeight)
	}

	// Get threshold
	threshold := 70 // Default
	if t, ok := context["threshold"].(int); ok {
		threshold = t
	}

	// Determine if detected based on weighted score
	detected := finalScore >= threshold

	return detected, finalScore, matchedContent, detailsMap
}
