// Package detection provides the vulnerability detection engine for LLM responses
package detection

import (
	"context"
	"fmt"
	"sync"
	"time"
)

// DefaultDetectionEngine is the default implementation of the DetectionEngine interface
type DefaultDetectionEngine struct {
	// detectors is a map of detector name to detector
	detectors map[string]VulnerabilityDetector
	// preHooks are functions to run before detection
	preHooks []DetectionHook
	// postHooks are functions to run after detection
	postHooks []DetectionHook
	// remediationProvider provides remediation suggestions
	remediationProvider RemediationProvider
	// standardMappingProvider provides standard mappings
	standardMappingProvider StandardMappingProvider
	// mutex protects the detectors map
	mutex sync.RWMutex
}

// NewDetectionEngine creates a new default detection engine
func NewDetectionEngine() *DefaultDetectionEngine {
	return &DefaultDetectionEngine{
		detectors: make(map[string]VulnerabilityDetector),
	}
}

// RegisterDetector registers a vulnerability detector
func (e *DefaultDetectionEngine) RegisterDetector(detector VulnerabilityDetector) {
	e.mutex.Lock()
	defer e.mutex.Unlock()
	e.detectors[detector.Name()] = detector
}

// GetDetector gets a detector by name
func (e *DefaultDetectionEngine) GetDetector(name string) (VulnerabilityDetector, bool) {
	e.mutex.RLock()
	defer e.mutex.RUnlock()
	detector, ok := e.detectors[name]
	return detector, ok
}

// ListDetectors lists all registered detectors
func (e *DefaultDetectionEngine) ListDetectors() []string {
	e.mutex.RLock()
	defer e.mutex.RUnlock()
	var detectorNames []string
	for name := range e.detectors {
		detectorNames = append(detectorNames, name)
	}
	return detectorNames
}

// RegisterPreHook registers a hook to run before detection
func (e *DefaultDetectionEngine) RegisterPreHook(hook DetectionHook) {
	e.preHooks = append(e.preHooks, hook)
}

// RegisterPostHook registers a hook to run after detection
func (e *DefaultDetectionEngine) RegisterPostHook(hook DetectionHook) {
	e.postHooks = append(e.postHooks, hook)
}

// SetRemediationProvider sets the remediation provider
func (e *DefaultDetectionEngine) SetRemediationProvider(provider RemediationProvider) {
	e.remediationProvider = provider
}

// SetStandardMappingProvider sets the standard mapping provider
func (e *DefaultDetectionEngine) SetStandardMappingProvider(provider StandardMappingProvider) {
	e.standardMappingProvider = provider
}

// Detect detects vulnerabilities in an LLM response using all registered detectors
func (e *DefaultDetectionEngine) Detect(ctx context.Context, response string, criteria []DetectionCriteria) ([]*DetectionResult, error) {
	e.mutex.RLock()
	defer e.mutex.RUnlock()

	if len(criteria) == 0 {
		return nil, fmt.Errorf("no detection criteria provided")
	}

	var results []*DetectionResult
	var wg sync.WaitGroup
	var mu sync.Mutex
	errChan := make(chan error, len(criteria))

	for _, c := range criteria {
		wg.Add(1)
		go func(c DetectionCriteria) {
			defer wg.Done()

			// Run pre-hooks
			for _, hook := range e.preHooks {
				if err := hook(ctx, response, c, nil); err != nil {
					errChan <- fmt.Errorf("pre-hook failed: %w", err)
					return
				}
			}

			// Get detector based on criteria type
			detector, ok := e.getDetectorForCriteria(c)
			if !ok {
				errChan <- fmt.Errorf("no detector found for criteria type: %s", c.Type)
				return
			}

			// Detect vulnerability
			result, err := detector.Detect(ctx, response, c)
			if err != nil {
				errChan <- fmt.Errorf("detection failed: %w", err)
				return
			}

			// Set timestamp if not already set
			if result.Timestamp.IsZero() {
				result.Timestamp = time.Now()
			}

			// Add standard mappings if available
			if e.standardMappingProvider != nil && len(result.StandardMappings) == 0 {
				mappings, err := e.standardMappingProvider.GetStandardMappings(ctx, result.VulnerabilityType, result.Severity)
				if err == nil {
					result.StandardMappings = mappings
				}
			}

			// Add remediation suggestion if available
			if e.remediationProvider != nil && result.RemediationSuggestion == "" && result.Detected {
				remediation, err := e.remediationProvider.GetRemediation(ctx, result)
				if err == nil {
					result.RemediationSuggestion = remediation
				}
			}

			// Run post-hooks
			for _, hook := range e.postHooks {
				if err := hook(ctx, response, c, result); err != nil {
					errChan <- fmt.Errorf("post-hook failed: %w", err)
					return
				}
			}

			// Add result to results
			mu.Lock()
			results = append(results, result)
			mu.Unlock()
		}(c)
	}

	// Wait for all detections to complete
	wg.Wait()
	close(errChan)

	// Check for errors
	for err := range errChan {
		return results, err
	}

	return results, nil
}

// DetectWithDetector detects vulnerabilities in an LLM response using a specific detector
func (e *DefaultDetectionEngine) DetectWithDetector(ctx context.Context, response string, criteria DetectionCriteria, detectorName string) (*DetectionResult, error) {
	e.mutex.RLock()
	defer e.mutex.RUnlock()

	// Get detector
	detector, ok := e.detectors[detectorName]
	if !ok {
		return nil, fmt.Errorf("detector not found: %s", detectorName)
	}

	// Run pre-hooks
	for _, hook := range e.preHooks {
		if err := hook(ctx, response, criteria, nil); err != nil {
			return nil, fmt.Errorf("pre-hook failed: %w", err)
		}
	}

	// Detect vulnerability
	result, err := detector.Detect(ctx, response, criteria)
	if err != nil {
		return nil, fmt.Errorf("detection failed: %w", err)
	}

	// Set timestamp if not already set
	if result.Timestamp.IsZero() {
		result.Timestamp = time.Now()
	}

	// Add standard mappings if available
	if e.standardMappingProvider != nil && len(result.StandardMappings) == 0 {
		mappings, err := e.standardMappingProvider.GetStandardMappings(ctx, result.VulnerabilityType, result.Severity)
		if err == nil {
			result.StandardMappings = mappings
		}
	}

	// Add remediation suggestion if available
	if e.remediationProvider != nil && result.RemediationSuggestion == "" && result.Detected {
		remediation, err := e.remediationProvider.GetRemediation(ctx, result)
		if err == nil {
			result.RemediationSuggestion = remediation
		}
	}

	// Run post-hooks
	for _, hook := range e.postHooks {
		if err := hook(ctx, response, criteria, result); err != nil {
			return nil, fmt.Errorf("post-hook failed: %w", err)
		}
	}

	return result, nil
}

// BatchDetect performs batch detection of vulnerabilities
func (e *DefaultDetectionEngine) BatchDetect(ctx context.Context, requests []BatchDetectionRequest) ([]BatchDetectionResult, error) {
	var results []BatchDetectionResult
	var wg sync.WaitGroup
	var mu sync.Mutex
	errChan := make(chan error, len(requests))

	for _, req := range requests {
		wg.Add(1)
		go func(req BatchDetectionRequest) {
			defer wg.Done()

			var result BatchDetectionResult
			result.Response = req.Response

			if req.DetectorName != "" {
				// Detect with specific detector
				var detectionResults []*DetectionResult
				for _, criteria := range req.Criteria {
					detectionResult, err := e.DetectWithDetector(ctx, req.Response, criteria, req.DetectorName)
					if err != nil {
						result.Error = err.Error()
						mu.Lock()
						results = append(results, result)
						mu.Unlock()
						return
					}
					detectionResults = append(detectionResults, detectionResult)
				}
				result.Results = detectionResults
			} else {
				// Detect with all detectors
				detectionResults, err := e.Detect(ctx, req.Response, req.Criteria)
				if err != nil {
					result.Error = err.Error()
					mu.Lock()
					results = append(results, result)
					mu.Unlock()
					return
				}
				result.Results = detectionResults
			}

			mu.Lock()
			results = append(results, result)
			mu.Unlock()
		}(req)
	}

	// Wait for all detections to complete
	wg.Wait()
	close(errChan)

	// Check for errors
	for err := range errChan {
		return results, err
	}

	return results, nil
}

// getDetectorForCriteria gets a detector for a specific criteria type
func (e *DefaultDetectionEngine) getDetectorForCriteria(criteria DetectionCriteria) (VulnerabilityDetector, bool) {
	// If criteria specifies a function name, use the corresponding detector
	if criteria.FunctionName != "" {
		detector, ok := e.detectors[criteria.FunctionName]
		return detector, ok
	}

	// Otherwise, use a detector based on the criteria type
	switch criteria.Type {
	case StringMatch:
		detector, ok := e.detectors["string_matcher"]
		return detector, ok
	case RegexMatch:
		detector, ok := e.detectors["regex_matcher"]
		return detector, ok
	case SemanticMatch:
		detector, ok := e.detectors["semantic_matcher"]
		return detector, ok
	case HybridMatch:
		detector, ok := e.detectors["hybrid_matcher"]
		return detector, ok
	default:
		// Try to find a detector with a matching name
		detector, ok := e.detectors[string(criteria.Type)]
		return detector, ok
	}
}
