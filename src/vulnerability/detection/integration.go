// Package detection provides the vulnerability detection engine for LLM responses
package detection

import (
	"context"
	"fmt"
)

// TemplateIntegration provides integration with template systems
type TemplateIntegration struct {
	// engine is the detection engine
	engine DetectionEngine

// TemplateInfo represents template information
type TemplateInfo struct {
	ID          string
	Name        string
	Description string
	Severity    string
	Tags        []string
	Compliance  struct {
		OWASP string
		ISO   string
	}
}

// TemplateDetection represents detection criteria in a template
type TemplateDetection struct {
	Type      string
	Match     string
	Pattern   string
	Criteria  string
	Condition string
}

// TemplateVariation represents a variation of a template test
type TemplateVariation struct {
	Prompt    string
	Detection TemplateDetection

// TemplateTest represents the test section of a template
type TemplateTest struct {
	Prompt     string
	Detection  TemplateDetection
	Variations []TemplateVariation
}

// Template represents a simplified template structure
type Template struct {
	ID    string
	Info  TemplateInfo
	Test  TemplateTest
}

// TemplateResult represents the result of a template execution
type TemplateResult struct {
	TemplateID string
	Status     string
	StartTime  time.Time
	EndTime    time.Time
	Duration   time.Duration
	Error      error
	Response   string
	Detected   bool
	Score      int
	Details    map[string]interface{}

// NewTemplateIntegration creates a new template integration
func NewTemplateIntegration(engine DetectionEngine) *TemplateIntegration {
	return &TemplateIntegration{
		engine: engine,
	}

// ConvertTemplateToCriteria converts a template to detection criteria
func (i *TemplateIntegration) ConvertTemplateToCriteria(template *Template) ([]DetectionCriteria, error) {
	if template == nil {
		return nil, fmt.Errorf("template is nil")
	}

	// Create criteria from template detection
	criteria := []DetectionCriteria{
		{
			Type:      DetectionMethod(template.Test.Detection.Type),
			Pattern:   template.Test.Detection.Pattern,
			Match:     template.Test.Detection.Match,
			Criteria:  template.Test.Detection.Criteria,
			Condition: template.Test.Detection.Condition,
			Context: map[string]interface{}{
				"vulnerability_type": getVulnerabilityTypeFromTemplate(template),
				"severity":           getSeverityFromTemplate(template),
				"template_id":        template.ID,
			},
		},
	}

	// Add criteria from variations
	for _, variation := range template.Test.Variations {
		criteria = append(criteria, DetectionCriteria{
			Type:      DetectionMethod(variation.Detection.Type),
			Pattern:   variation.Detection.Pattern,
			Match:     variation.Detection.Match,
			Criteria:  variation.Detection.Criteria,
			Condition: variation.Detection.Condition,
			Context: map[string]interface{}{
				"vulnerability_type": getVulnerabilityTypeFromTemplate(template),
				"severity":           getSeverityFromTemplate(template),
				"template_id":        template.ID,
				"variation":          true,
			},
		})
	}

	return criteria, nil

// DetectFromTemplate detects vulnerabilities using a template
func (i *TemplateIntegration) DetectFromTemplate(ctx context.Context, template *Template, response string) (*TemplateResult, error) {
	// Convert template to criteria
	criteria, err := i.ConvertTemplateToCriteria(template)
	if err != nil {
		return nil, fmt.Errorf("failed to convert template to criteria: %w", err)
	}

	// Detect vulnerabilities
	results, err := i.engine.Detect(ctx, response, criteria)
	if err != nil {
		return nil, fmt.Errorf("detection failed: %w", err)
	}

	// Create template result
	templateResult := &TemplateResult{
		TemplateID: template.ID,
		Status:     "completed",
		StartTime:  time.Now(),
		EndTime:    time.Now(),
		Response:   response,
		Detected:   false,
		Score:      0,
		Details:    make(map[string]interface{}),
	}

	// Update template result with detection results
	for _, result := range results {
		if result.Detected {
			templateResult.Detected = true
			if result.ConfidenceScore > templateResult.Score {
				templateResult.Score = result.ConfidenceScore
			}

			// Add details
			if templateResult.Details == nil {
				templateResult.Details = make(map[string]interface{})
			}

			// Add result to details
			resultKey := fmt.Sprintf("result_%s", result.DetectionMethod)
			templateResult.Details[resultKey] = map[string]interface{}{
				"vulnerability_type": result.VulnerabilityType,
				"severity":           result.Severity,
				"confidence_score":   result.ConfidenceScore,
				"matched_content":    result.MatchedContent,
				"context":            result.Context,
			}

			// Add standard mappings
			if len(result.StandardMappings) > 0 {
				templateResult.Details["standard_mappings"] = result.StandardMappings
			}

			// Add remediation suggestion
			if result.RemediationSuggestion != "" {
				templateResult.Details["remediation_suggestion"] = result.RemediationSuggestion
			}
		}
	}

	return templateResult, nil

// BatchDetectFromTemplates detects vulnerabilities using multiple templates
func (i *TemplateIntegration) BatchDetectFromTemplates(ctx context.Context, templates []*Template, response string) ([]*TemplateResult, error) {
	var results []*TemplateResult

	for _, template := range templates {
		result, err := i.DetectFromTemplate(ctx, template, response)
		if err != nil {
			return results, fmt.Errorf("detection failed for template %s: %w", template.ID, err)
		}
		results = append(results, result)
	}

	return results, nil

// getVulnerabilityTypeFromTemplate extracts the vulnerability type from a template
func getVulnerabilityTypeFromTemplate(template *Template) VulnerabilityType {
	// Try to map from OWASP category
	if template.Info.Compliance.OWASP != "" {
		switch template.Info.Compliance.OWASP {
		case "LLM01":
			return PromptInjection
		case "LLM02":
			return InsecureCode
		case "LLM03", "LLM05", "LLM06":
			return SensitiveInfoDisclosure
		case "LLM04", "LLM10":
			return ModelDoS
		case "LLM07":
			return InsecureCode
		case "LLM08", "LLM09":
			return Overreliance
		}
	}

	// Try to infer from tags
	for _, tag := range template.Info.Tags {
		switch tag {
		case "prompt-injection":
			return PromptInjection
		case "jailbreak":
			return Jailbreak
		case "sensitive-info":
			return SensitiveInfoDisclosure
		case "harmful-content":
			return HarmfulContent
		case "insecure-code":
			return InsecureCode
		case "data-poisoning":
			return DataPoisoning
		case "model-dos":
			return ModelDoS
		case "unauthorized-access":
			return UnauthorizedAccess
		case "overreliance":
			return Overreliance
		}
	}

	// Default to prompt injection
	return PromptInjection

// getSeverityFromTemplate extracts the severity from a template
func getSeverityFromTemplate(template *Template) SeverityLevel {
	switch template.Info.Severity {
	case "critical":
		return Critical
	case "high":
		return High
	case "medium":
		return Medium
	case "low":
		return Low
	case "info":
		return Info
	default:
		return Medium
	}
}
}
