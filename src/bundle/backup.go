// Package bundle provides functionality for importing and exporting bundles
package bundle

import (
	"context"
	"encoding/json"
	"fmt"
)

// BackupMetadata contains metadata about a backup
type BackupMetadata struct {
	// ID is the unique identifier for the backup
	ID string `json:"id"`
	// CreatedAt is the time the backup was created
	CreatedAt time.Time `json:"created_at"`
	// Description is a human-readable description of the backup
	Description string `json:"description"`
	// BundleID is the ID of the bundle that was being imported when the backup was created
	BundleID string `json:"bundle_id,omitempty"`
	// BundleName is the name of the bundle that was being imported when the backup was created
	BundleName string `json:"bundle_name,omitempty"`
	// BundleVersion is the version of the bundle that was being imported when the backup was created
	BundleVersion string `json:"bundle_version,omitempty"`
	// ContentPaths contains the paths of the content items in the backup
	ContentPaths []string `json:"content_paths,omitempty"`
	// Tags contains tags for the backup
	Tags []string `json:"tags,omitempty"`
	// AutoGenerated indicates whether the backup was automatically generated
	AutoGenerated bool `json:"auto_generated"`
}

// BackupManager defines the interface for backup management
type BackupManager interface {
	// CreateBackup creates a backup of the specified directory
	CreateBackup(ctx context.Context, sourceDir, backupDir, description string, tags []string) (string, error)
	// CreateBundleBackup creates a backup before importing a bundle
	CreateBundleBackup(ctx context.Context, sourceDir, backupDir string, bundle *Bundle) (string, error)
	// RestoreBackup restores a backup to the specified directory
	RestoreBackup(ctx context.Context, backupPath, targetDir string) error
	// ListBackups lists all backups in the specified directory
	ListBackups(ctx context.Context, backupDir string) ([]BackupMetadata, error)
	// GetBackupMetadata gets the metadata for a backup
	GetBackupMetadata(ctx context.Context, backupPath string) (*BackupMetadata, error)
	// DeleteBackup deletes a backup
	DeleteBackup(ctx context.Context, backupPath string) error
	// PruneBackups deletes old backups, keeping the specified number of most recent backups
	PruneBackups(ctx context.Context, backupDir string, keepCount int) (int, error)
}

// DefaultBackupManager is the default implementation of BackupManager
type DefaultBackupManager struct {
	// Logger is the logger for backup operations
	Logger io.Writer
}

// NewBackupManager creates a new backup manager
func NewBackupManager(logger io.Writer) BackupManager {
	if logger == nil {
		logger = os.Stdout
	}
	return &DefaultBackupManager{
		Logger: logger,
	}
}

// CreateBackup creates a backup of the specified directory
func (m *DefaultBackupManager) CreateBackup(ctx context.Context, sourceDir, backupDir, description string, tags []string) (string, error) {
	// Check if source directory exists
	if _, err := os.Stat(sourceDir); os.IsNotExist(err) {
		return "", fmt.Errorf("source directory does not exist: %w", err)
	}

	// Create backup directory if it doesn't exist
	if _, err := os.Stat(backupDir); os.IsNotExist(err) {
		err = os.MkdirAll(backupDir, 0755)
		if err != nil {
			return "", fmt.Errorf("failed to create backup directory: %w", err)
		}
	}

	// Create backup ID and path
	backupID := fmt.Sprintf("backup-%s", time.Now().Format("20060102-150405"))
	backupPath := filepath.Join(backupDir, backupID)

	// Create backup directory
	err := os.Mkdir(backupPath, 0755)
	if err != nil {
		return "", fmt.Errorf("failed to create backup directory: %w", err)
	}

	// Create content directory
	contentDir := filepath.Join(backupPath, "content")
	err = os.Mkdir(contentDir, 0755)
	if err != nil {
		return "", fmt.Errorf("failed to create content directory: %w", err)
	}

	// Copy source directory to backup content directory
	err = copyDir(sourceDir, contentDir)
	if err != nil {
		// Cleanup on failure
		os.RemoveAll(backupPath)
		return "", fmt.Errorf("failed to copy source directory to backup: %w", err)
	}

	// Walk the content directory to get content paths
	var contentPaths []string
	err = filepath.Walk(contentDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			relPath, err := filepath.Rel(contentDir, path)
			if err != nil {
				return err
			}
			contentPaths = append(contentPaths, relPath)
		}
		return nil
	})
	if err != nil {
		// Cleanup on failure
		os.RemoveAll(backupPath)
		return "", fmt.Errorf("failed to walk content directory: %w", err)
	}

	// Create metadata
	metadata := BackupMetadata{
		ID:            backupID,
		CreatedAt:     time.Now().UTC(),
		Description:   description,
		ContentPaths:  contentPaths,
		Tags:          tags,
		AutoGenerated: false,
	}

	// Write metadata
	err = m.writeMetadata(backupPath, &metadata)
	if err != nil {
		// Cleanup on failure
		os.RemoveAll(backupPath)
		return "", fmt.Errorf("failed to write metadata: %w", err)
	}

	// Log backup creation
	fmt.Fprintf(m.Logger, "Created backup at: %s\n", backupPath)

	return backupPath, nil
}

// CreateBundleBackup creates a backup before importing a bundle
func (m *DefaultBackupManager) CreateBundleBackup(ctx context.Context, sourceDir, backupDir string, bundle *Bundle) (string, error) {
	// Create description
	description := fmt.Sprintf("Backup before importing bundle: %s", bundle.Manifest.Name)

	// Create tags
	tags := []string{"bundle-import", string(bundle.Manifest.BundleType)}

	// Create backup
	backupPath, err := m.CreateBackup(ctx, sourceDir, backupDir, description, tags)
	if err != nil {
		return "", err
	}

	// Get metadata
	metadata, err := m.GetBackupMetadata(ctx, backupPath)
	if err != nil {
		return "", fmt.Errorf("failed to get backup metadata: %w", err)
	}

	// Update metadata with bundle information
	metadata.BundleID = bundle.Manifest.BundleID
	metadata.BundleName = bundle.Manifest.Name
	metadata.BundleVersion = bundle.Manifest.Version
	metadata.AutoGenerated = true

	// Write updated metadata
	err = m.writeMetadata(backupPath, metadata)
	if err != nil {
		return "", fmt.Errorf("failed to write updated metadata: %w", err)
	}

	return backupPath, nil
}

// RestoreBackup restores a backup to the specified directory
func (m *DefaultBackupManager) RestoreBackup(ctx context.Context, backupPath, targetDir string) error {
	// Check if backup directory exists
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		return fmt.Errorf("backup directory does not exist: %w", err)
	}

	// Get content directory
	contentDir := filepath.Join(backupPath, "content")
	if _, err := os.Stat(contentDir); os.IsNotExist(err) {
		return fmt.Errorf("backup content directory does not exist: %w", err)
	}

	// Check if target directory exists
	if _, err := os.Stat(targetDir); os.IsNotExist(err) {
		// Create target directory
		err = os.MkdirAll(targetDir, 0755)
		if err != nil {
			return fmt.Errorf("failed to create target directory: %w", err)
		}
	} else {
		// Clear target directory
		err = clearDirectory(targetDir)
		if err != nil {
			return fmt.Errorf("failed to clear target directory: %w", err)
		}
	}

	// Copy backup content to target directory
	err := copyDir(contentDir, targetDir)
	if err != nil {
		return fmt.Errorf("failed to copy backup to target directory: %w", err)
	}

	// Log backup restoration
	fmt.Fprintf(m.Logger, "Restored backup from: %s to: %s\n", backupPath, targetDir)

	return nil
}

// ListBackups lists all backups in the specified directory
func (m *DefaultBackupManager) ListBackups(ctx context.Context, backupDir string) ([]BackupMetadata, error) {
	// Check if backup directory exists
	if _, err := os.Stat(backupDir); os.IsNotExist(err) {
		return []BackupMetadata{}, nil
	}

	// Read backup directory
	entries, err := os.ReadDir(backupDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read backup directory: %w", err)
	}

	// Get metadata for each backup
	var backups []BackupMetadata
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		backupPath := filepath.Join(backupDir, entry.Name())
		metadata, err := m.GetBackupMetadata(ctx, backupPath)
		if err != nil {
			// Skip backups with invalid metadata
			fmt.Fprintf(m.Logger, "Warning: Failed to get metadata for backup %s: %v\n", backupPath, err)
			continue
		}

		backups = append(backups, *metadata)
	}

	return backups, nil
}

// GetBackupMetadata gets the metadata for a backup
func (m *DefaultBackupManager) GetBackupMetadata(ctx context.Context, backupPath string) (*BackupMetadata, error) {
	// Check if backup directory exists
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("backup directory does not exist: %w", err)
	}

	// Read metadata file
	metadataPath := filepath.Join(backupPath, "metadata.json")
	metadataData, err := os.ReadFile(metadataPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read metadata file: %w", err)
	}

	// Unmarshal metadata
	var metadata BackupMetadata
	err = json.Unmarshal(metadataData, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
	}

	return &metadata, nil
}

// DeleteBackup deletes a backup
func (m *DefaultBackupManager) DeleteBackup(ctx context.Context, backupPath string) error {
	// Check if backup directory exists
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		return fmt.Errorf("backup directory does not exist: %w", err)
	}

	// Delete backup directory
	err := os.RemoveAll(backupPath)
	if err != nil {
		return fmt.Errorf("failed to delete backup directory: %w", err)
	}

	// Log backup deletion
	fmt.Fprintf(m.Logger, "Deleted backup: %s\n", backupPath)

	return nil
}

// PruneBackups deletes old backups, keeping the specified number of most recent backups
func (m *DefaultBackupManager) PruneBackups(ctx context.Context, backupDir string, keepCount int) (int, error) {
	// Check if backup directory exists
	if _, err := os.Stat(backupDir); os.IsNotExist(err) {
		return 0, nil
	}

	// List backups
	backups, err := m.ListBackups(ctx, backupDir)
	if err != nil {
		return 0, fmt.Errorf("failed to list backups: %w", err)
	}

	// Sort backups by creation time (newest first)
	sortBackupsByCreationTime(backups)

	// If we have fewer backups than the keep count, do nothing
	if len(backups) <= keepCount {
		return 0, nil
	}

	// Delete old backups
	deletedCount := 0
	for i := keepCount; i < len(backups); i++ {
		backupPath := filepath.Join(backupDir, backups[i].ID)
		err := m.DeleteBackup(ctx, backupPath)
		if err != nil {
			fmt.Fprintf(m.Logger, "Warning: Failed to delete backup %s: %v\n", backupPath, err)
			continue
		}
		deletedCount++
	}

	// Log pruning
	fmt.Fprintf(m.Logger, "Pruned %d backups, keeping %d most recent\n", deletedCount, keepCount)

	return deletedCount, nil
}

// writeMetadata writes metadata to a backup
func (m *DefaultBackupManager) writeMetadata(backupPath string, metadata *BackupMetadata) error {
	// Marshal metadata
	metadataData, err := json.MarshalIndent(metadata, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal metadata: %w", err)
	}

	// Write metadata file
	metadataPath := filepath.Join(backupPath, "metadata.json")
	err = os.WriteFile(metadataPath, metadataData, 0644)
	if err != nil {
		return fmt.Errorf("failed to write metadata file: %w", err)
	}

	return nil
}

// sortBackupsByCreationTime sorts backups by creation time (newest first)
func sortBackupsByCreationTime(backups []BackupMetadata) {
	for i := 0; i < len(backups); i++ {
		for j := i + 1; j < len(backups); j++ {
			if backups[i].CreatedAt.Before(backups[j].CreatedAt) {
				backups[i], backups[j] = backups[j], backups[i]
			}
		}
	}
}

// RollbackManager defines the interface for rollback management
type RollbackManager interface {
	// CreateRollbackPoint creates a rollback point
	CreateRollbackPoint(ctx context.Context, targetDir, backupDir, description string) (string, error)
	// Rollback rolls back to a rollback point
	Rollback(ctx context.Context, rollbackPointPath, targetDir string) error
	// ListRollbackPoints lists all rollback points
	ListRollbackPoints(ctx context.Context, backupDir string) ([]BackupMetadata, error)
	// DeleteRollbackPoint deletes a rollback point
	DeleteRollbackPoint(ctx context.Context, rollbackPointPath string) error
}

// DefaultRollbackManager is the default implementation of RollbackManager
type DefaultRollbackManager struct {
	// BackupManager is the backup manager to use for rollback operations
	BackupManager BackupManager
}

// NewRollbackManager creates a new rollback manager
func NewRollbackManager(backupManager BackupManager) RollbackManager {
	if backupManager == nil {
		backupManager = NewBackupManager(os.Stdout)
	}
	return &DefaultRollbackManager{
		BackupManager: backupManager,
	}
}

// CreateRollbackPoint creates a rollback point
func (m *DefaultRollbackManager) CreateRollbackPoint(ctx context.Context, targetDir, backupDir, description string) (string, error) {
	// Create tags
	tags := []string{"rollback-point"}

	// Create backup
	return m.BackupManager.CreateBackup(ctx, targetDir, backupDir, description, tags)
}

// Rollback rolls back to a rollback point
func (m *DefaultRollbackManager) Rollback(ctx context.Context, rollbackPointPath, targetDir string) error {
	// Restore backup
	return m.BackupManager.RestoreBackup(ctx, rollbackPointPath, targetDir)
}

// ListRollbackPoints lists all rollback points
func (m *DefaultRollbackManager) ListRollbackPoints(ctx context.Context, backupDir string) ([]BackupMetadata, error) {
	// List all backups
	backups, err := m.BackupManager.ListBackups(ctx, backupDir)
	if err != nil {
		return nil, err
	}

	// Filter rollback points
	var rollbackPoints []BackupMetadata
	for _, backup := range backups {
		for _, tag := range backup.Tags {
			if tag == "rollback-point" {
				rollbackPoints = append(rollbackPoints, backup)
				break
			}
		}
	}

	return rollbackPoints, nil
}

// DeleteRollbackPoint deletes a rollback point
func (m *DefaultRollbackManager) DeleteRollbackPoint(ctx context.Context, rollbackPointPath string) error {
	// Delete backup
	return m.BackupManager.DeleteBackup(ctx, rollbackPointPath)
}
