package cmd

import (
	"path/filepath"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"github.com/perplext/LLMrecon/src/vulnerability/detection"
	"github.com/spf13/cobra"
)

// vulnerabilityDetectionCmd represents the vulnerability detection command
var vulnerabilityDetectionCmd = &cobra.Command{
	Use:   "detect",
	Short: "Detect vulnerabilities in LLM responses",
	Long: `Detect vulnerabilities in LLM responses using the vulnerability detection engine.
	
This command can analyze LLM responses against various detection criteria to identify
security vulnerabilities based on template-defined criteria.`,
	Run: func(cmd *cobra.Command, args []string) {
		// Get flags
		responseFile, _ := cmd.Flags().GetString("response")
		criteriaFile, _ := cmd.Flags().GetString("criteria")
		outputFile, _ := cmd.Flags().GetString("output")
		verbose, _ := cmd.Flags().GetBool("verbose")

		// Create factory
		factory := detection.NewFactory()

		// Create detection engine
		engine := factory.CreateDetectionEngine()

		// Read response
		response, err := readResponseFile(responseFile)
		if err != nil {
			fmt.Printf("Error reading response file: %v\n", err)
			os.Exit(1)
		}

		// Read criteria
		criteria, err := readCriteriaFile(criteriaFile)
		if err != nil {
			fmt.Printf("Error reading criteria file: %v\n", err)
			os.Exit(1)
		}

		// Detect vulnerabilities
		results, err := engine.Detect(context.Background(), response, criteria)
		if err != nil {
			fmt.Printf("Error detecting vulnerabilities: %v\n", err)
			os.Exit(1)
		}

		// Print results
		printResults(results, verbose)

		// Write results to file if specified
		if outputFile != "" {
			if err := writeResultsToFile(results, outputFile); err != nil {
				fmt.Printf("Error writing results to file: %v\n", err)
				os.Exit(1)
			}
			fmt.Printf("Results written to %s\n", outputFile)
		}
	},

func init() {
	rootCmd.AddCommand(vulnerabilityDetectionCmd)

	// Add flags
	vulnerabilityDetectionCmd.Flags().StringP("response", "r", "", "Path to file containing LLM response")
	vulnerabilityDetectionCmd.Flags().StringP("criteria", "c", "", "Path to file containing detection criteria")
	vulnerabilityDetectionCmd.Flags().StringP("output", "o", "", "Path to output file for results")
	vulnerabilityDetectionCmd.Flags().BoolP("verbose", "v", false, "Enable verbose output")

	// Mark required flags
	vulnerabilityDetectionCmd.MarkFlagRequired("response")
	vulnerabilityDetectionCmd.MarkFlagRequired("criteria")

// readResponseFile reads the response from a file
func readResponseFile(filePath string) (string, error) {
	// Check if file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		return "", fmt.Errorf("response file does not exist: %s", filePath)
	}

	// Read file
	data, err := ioutil.ReadFile(filepath.Clean(filePath))
	if err != nil {
		return "", fmt.Errorf("failed to read response file: %w", err)
	}

	return string(data), nil
	

// readCriteriaFile reads the criteria from a file
func readCriteriaFile(filePath string) ([]detection.DetectionCriteria, error) {
	// Check if file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		return nil, fmt.Errorf("criteria file does not exist: %s", filePath)
	}
	// Read file
	data, err := ioutil.ReadFile(filepath.Clean(filePath))
	if err != nil {
		return nil, fmt.Errorf("failed to read criteria file: %w", err)
	}

	// Parse JSON
	var criteria []detection.DetectionCriteria
	if err := json.Unmarshal(data, &criteria); err != nil {
		return nil, fmt.Errorf("failed to parse criteria file: %w", err)
	}

	return criteria, nil

// printResults prints the detection results
func printResults(results []*detection.DetectionResult, verbose bool) {
	// Print summary
	fmt.Printf("Detected %d vulnerabilities\n", countDetected(results))
	fmt.Printf("Total results: %d\n", len(results))

	// Print details
	for i, result := range results {
		if result.Detected || verbose {
			fmt.Printf("\nResult %d:\n", i+1)
			fmt.Printf("  Detected: %t\n", result.Detected)
			if result.Detected {
				fmt.Printf("  Vulnerability Type: %s\n", result.VulnerabilityType)
				fmt.Printf("  Severity: %s\n", result.Severity)
				fmt.Printf("  Confidence Score: %d\n", result.ConfidenceScore)
				fmt.Printf("  Detection Method: %s\n", result.DetectionMethod)

				if len(result.StandardMappings) > 0 {
					fmt.Printf("  Standard Mappings:\n")
					for _, mapping := range result.StandardMappings {
						fmt.Printf("    - %s %s: %s\n", mapping.Standard, mapping.ID, mapping.Name)
					}
				}

				if len(result.MatchedContent) > 0 {
					fmt.Printf("  Matched Content:\n")
					for _, content := range result.MatchedContent {
						fmt.Printf("    - %s\n", content)
					}
				}

				if result.RemediationSuggestion != "" {
					fmt.Printf("  Remediation Suggestion: %s\n", result.RemediationSuggestion)
				}
			}
		}
	}

// countDetected counts the number of detected vulnerabilities
func countDetected(results []*detection.DetectionResult) int {
	count := 0
	for _, result := range results {
		if result.Detected {
			count++
		}
	}
	return count

// writeResultsToFile writes the results to a file
func writeResultsToFile(results []*detection.DetectionResult, filePath string) error {
	// Marshal to JSON
	data, err := json.MarshalIndent(results, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal results to JSON: %w", err)
	}

	// Write to file
	if err := ioutil.WriteFile(filePath, data, 0600); err != nil {
		return fmt.Errorf("failed to write results to file: %w", err)
	}

